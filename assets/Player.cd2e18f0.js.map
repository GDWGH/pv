{"version":3,"mappings":"2zEA2TAA,0FACAC,kCAEA,WAEAC,UACAC,aACAC,UACA,iBACAC,KAAe,sHAGY,EAI3BC,SACAC,QACAC,OACAC,QAGA,kCAGAC,UAEAC,QACAC,QACAC,uCACA,OACAC,mBACE,sBACEF,UAAmB,OAErBG,IAAgB,GAElBD,mBACEC,KACEA,KACAA,WAEFH,UAAmB,GAErB,OACAE,mBACE,sBACEH,UAAmB,OAErBK,IAAgB,GAElBF,mBACEE,KACEA,KACAA,WAEFL,UAAmB,GAErBG,sBACE,gEACEJ,eAAmB,GAGvB,eACAO,6DAGAC,SACA,MACA,sBACEC,GACEA,IACF,iBAAiB,KAEbD,WAAuB,EACzBE,EACA,cACkB,EAEpBD,GAAqB,UAEvBL,qBACEK,GACEA,IACFD,YACAG,UACEC,OAAyB,GAE7BR,sBACEQ,IAAsB,GAIxB,cAEAC,uCACAC,SACAC,SAEAC,WAA8D,SACnD,aACH,6CACwC,OACrC,CACL,WACQ,aACF,sDACiD,kBAC5B,EAC3B,CACA,aACQ,oDAC6C,UAC1C,EACX,iBAGO,CACC,aACQ,qDAC8C,UAC3C,EACX,CACA,aACQ,iEAC0D,UACvD,CACX,OAEE,CACZ,EACF,SACS,aACH,6CACwC,iBACpC,OACD,QAEHlB,UACK,CACC,YACQ,4DACuD,kDACE,gCACxB,EACtC,CACH,MAED,EACJ,SAED,WACA,2BACEmB,uBACEA,iBAA6B,GAEjCA,WAAiC,YACzB,oCACkD,iBACvB,GACjC,IACD,CACL,CACF,IAGFC,eACAC,2BAEAC,QACAC,YACED,8BAA8C,GAEhD,cACEF,sBAAwD,EAI1DI,SACAC,WACAC,MAEEF,YACAG,QACEF,UACEA,yBAA2B,WAClB,EAEX,EACD,EAIHG,QACAC,SACAC,QACED,WACEA,aACFD,gBAAyB,EAE3BG,QACE,kDACE,IACEnC,yCACEA,sBACAM,UACEA,wBAEJ0B,yBACEhC,eACF,2BACEA,eAAkB,OAEtB,CAGF,EAEFoC,WACAT,QACAjB,iBACEsB,UAAgB,GAElBK,QA+BE3B,gBACEL,mBACEC,wCACAA,eACF,GAEFI,iBACEL,mBACEC,wCACAA,gBACF,EACD,GAEH,aACAI,0BACE4B,wBAA8B,GAEhC,cAGAC,OACE,MACE,WACA,QACA,2BACEC,cACEC,QAAY,YACA,QACH,cACY,GAGvBA,QAAY,YACA,iBACW,YACJ,GAEnBD,WAEF,kBACEC,QAAY,YACA,QACH,WACO,GAGlBA,WAAwB,oBACV,sBACc,iBACJ,GACtB,KAGF,QAAO,CACL,YACY,QACH,KACF,CACP,CAEJ,EAEFC,OACAC,WACAC,uBACAC,WACAC,uBAEAC,0BACAC,UACAC,QACEjD,UACEA,6BACFM,UACEA,4BAAsC,EAE1CI,sBACEgC,4BACArC,UACEG,kBAOEF,8DACEA,sEACAA,gBAEFA,0CACEA,eACFA,0CACEA,kBAGFN,gBACA2B,IACE,KAEEpB,kBACEP,cAAkB,EACtB,cACgB,IAItBA,UACE2C,2BACFrC,UACEuC,0BAAsC,GAQ1CnC,gBACE,2EACAwC,4BACAR,kBACAO,IAAkB,GAEpBvC,oBACE,0BACE,2EACAwC,4BACAR,iBAA0C,GAE5CS,kBACEC,IACAD,IACAF,IAAkB,EACnB,GAIH,oEACAI,SACA1B,kBACE,cACA0B,WACEC,KACFtD,8BACEA,kBACFM,8BACEA,iBAAqB,GAEzB,gBACAI,gBACE,2EACAwC,4BACA,qBACEK,UAAe,GAEnB7C,oBACE,0BACE,2EACAwC,4BACA,qBACEK,UAAe,GAEnBJ,kBACEC,IACAD,GAAY,EACb,GAIH,2EACAK,4DACAC,2DACAC,oDACAC,SACA,eACE,mBACA,KACE,mEACF,mBACA,KACE,6CACF,mBACA,KACE,8CACF,mBACA,KACE,6CAA4C,CAEhD,eACE7B;AAAA,CAAqC,EACrC,cACA,UAIA6B,WACA5D,iBACA,KALE+B;AAAA,CAAqC,EACrC,GAIK,CAIT,+FAEA8B,eACE,oBACE,GACF,8CAEF,MACAC,QACEC,oBAAmB,GAErB,2BAgBE,IAfA,qBACE,sBACEnC,QACe,UAEXoC,MACEC,GAAQ,CACZ,CACF,GAGJ9D,WAEA4D,qBAEA9D,SACE8B;AAAA,CAAgE,EAChE,iIAGA,MACE;AAAA,CAA+D,EAC/D,GAEF,kOAOA,sBACE;AAAA,CAA+D,EAC/D,GAIF,IACE,oBAA0B,WAEtBA;AAAA,CAAgE,EAChE,IAEE,SADA,0IACA,QACAA;AAAA,CAAgE,EAChE,qBACEgC,kBAA+B,WACvB,uCACuC,GAE/CA,8BACAhC;AAAA,CAAgE,EAChEgC,SACAA,6BACEhC;AAAA,CAA+D,EAC/DmC,UAA0B,GAE5B5D,WACF,UAGA;AAAA,EAA+D6D;AAAA,CAAM,EACrE,EAAO,CAET,QAAO,CACT,gBACK,eAEH;AAAA,CAAqE,EACrElE,qBACAU,IACE,UACA,KAEEoB;AAAA,CAAoE,EACpE1B,WACA6D,UAA0B,EAC5B,SACa,EAEfE,iBACE7D,qCACAA,wCACAA,eACAD,YAEFL,eACA,EACF,CACF,UAGA;AAAA,EAAoDkE;AAAA,CAAM,EAC1D,EAAO,CACT,CACF,CAEF,qBACE,IACEpC;AAAA,CAA6C,EAW7C,cAVA,kEAA8E,cACpE,sBACK,qBACQ,iCACH,GACjB,qBACoB,KACnB,EACD,IAEH,OACA,WACE,SAEF,yBAA+B,gBAE3B3B,uBACA,mBASA,GARA2B,kDACkD,kBACtC,mBACO,iBACC;AAAA,CACjB,EAEHsC,YACA,oBACE,SACF,MACF,eAEE,SACA,WACAC,2BACEC,mBACEC,UAEAC,SAAkC,GAEtCA,0JAIArE,UACA,mBASA,GARA2B,kDACkD,iBACtC,mBACO,iBACC;AAAA,CACjB,EAGH,oBACE,SACF,MACF,SAEEA,4EACA,MACF,CAEF,QAAO,OAGP,QAAO,CACT,CAGF,UAAwB,SACtB,EAKF,qBAME,MALA,wBACE,iBAIF2C,UAEO,CAGT,eACA9C,kBACmB,UAEf,eAEAG;AAAA,CAA2C,EAC3C4C,qBACA5C;AAAA,CAAqD,EACrD6C,YAAoB,EACtB,CACA,YACa,CACb,EAGF,iBACA,CACEC,QACE,+BACE7E,iBAAkB,GAEtB6E,QACExD,SACErB,iBAAkBA,qBAGlBA,gBAAkB,GAEtB,MACA8E,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,MACA,YACAR,QACE/D,yBACE+D,QACE,iCACEO,GACEA,IACFE,mBACAJ,sCACAC,kBAAkB,+BAGlBC,GACEA,IACFE,mBACAJ,sCACAC,cAGA,QAEFL,iBACAxB,YACAyB,qBACAA,kBACAA,kBACAA,2BACAA,eACAC,4BACAC,oBAEAK,uBACEA,WACFJ,aACAA,aACAJ,yBACAM,OACEE,mBACAJ,yBACAA,SACAJ,yBACAA,SACAC,yBACAA,SACAK,QAAQ,CACV,GAEFP,QACEC,IACEA,qBAA6B,GAEjCO,MACF,GAEFvB,QACEsB,GACEA,GAAM,GAEV,SACA,WACA,wBAAiE,KAE7D,iBACAG,WACA,8BACE,+BACAC,0BACAC,qBACA,MACE,OAYF,GATAnE,SACEmE,uBAGAA,yBACAA,sBAIFV,SACEA,0BACA,mBAEAW,IADAC,mBACAX,QACA,SACA,6BACE,gBACAS,2CACAA,cACA,iCACAG,YACAH,gBACAA,kCACA,0BACAA,iCACAA,eACAA,SACAI,QAAS,CACX,CAIF,CACEC,0BACAA,aACEA,UACFL,+BACA,oEAA8E,mCACvB,IAEvDC,iCACAD,mBAAwB,CAC1B,CACF,EACF,cACmB,EAErB7D,YAC6C,KAEzC5B,2DAME+F,MACF/F,4DAMEgG,IAAkB,EACtB,cACkB,CACpB","names":["qualities","formats","root","usePlayer","video","height","streamQuality","streams","currentStream","hasAudioStream","audio","audioReady","videoReady","streamsReady","useEventListener","stopVideoWait","stopAudioWait","crossorigin","showControlBar","stopHideControlBar","delay","isFullscreen","delayedHideControlBar","syncAudio","useCanvas","canvasTransparent","settings","qualities2","activeSettingsItemName","activeSettingsItem","transToParent","watch","logText","logEl","log","nextTick","playing","userClickedPlaying","onPlayPause","updatePlaying","useIntervalFn","onMounted","duration","computeLoadedRanges","last","ranges","currentTime","videoLoadedAmount","videoLoadedRanges","audioLoadedAmount","audioLoadedRanges","progress","progressbar","updateCurrentTime","percentage","stopMouseUp","stopMouseMove","keepElementVolume","target","volume","regNico","regU2b","regAcf","iframeUrl","isContainerSupported","onUnmounted","flvPlayer","video2","resolve","videoElementReady","e","stream","videoHasCors","result","s","audioStreams","videoStreams","loadIframe","url","loadVideo","watchEffect","gainNode","analyser","frequencyBufferLength","frequencyBuffer","source","audioSourceType","clear","watched","audioCtx","vid","height2","ctx","w","width2","by","x","ltrds","resumeCanvasRender","pauseCanvasRender"],"sources":["../../packages/video/components/Player.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"root\"\n    class=\"root relative w-full bg-black overflow-hidden\"\n    :class=\"{ 'h-full': fullHeight }\"\n    :style=\"{ height: fullHeight ? undefined : `${height}px` }\"\n  >\n    <video\n      v-show=\"videoElementReady && (usePlayer === 'video' || (usePlayer === 'canvas' && canvasTransparent))\"\n      ref=\"video\"\n      class=\"video w-full h-full focus:outline-none\"\n      playsinline\n      preload=\"auto\"\n      :crossorigin=\"crossorigin ? '' : undefined\"\n    />\n    <audio ref=\"audio\" class=\"hidden\" :crossorigin=\"crossorigin ? '' : undefined\" />\n    <iframe\n      v-if=\"usePlayer === 'iframe' && iframeUrl\"\n      title=\"Video Player\"\n      class=\"block w-full h-full\"\n      :src=\"iframeUrl\"\n      allow=\"fullscreen\"\n      sandbox=\"allow-scripts allow-popups-to-escape-sandbox allow-same-origin\"\n    />\n    <canvas v-show=\"usePlayer === 'canvas'\" ref=\"canvas\" class=\"absolute top-0 w-full h-full\" />\n    <!-- top -->\n    <div\n      v-show=\"videoElementReady && !(usePlayer === 'iframe')\"\n      class=\"absolute top-0 left-0 right-0 bg-black bg-opcity-75 transform transition-all ease-in-out duration-300\"\n      :class=\"{ '-translate-y-3/2': !showSettings && !showControlBar && userClickedPlaying }\"\n    >\n      <div class=\"m-2 flex justify-between\">\n        <div\n          class=\"flex-nowrap text-white whitespace-nowrap overflow-hidden\"\n          :class=\"{ 'ml-2': !item.title.startsWith('【') }\"\n          v-text=\"item.title\"\n        />\n        <div @click=\"showSettings = true\">\n          <div class=\"i-uil:setting text-white text-2xl\" />\n        </div>\n      </div>\n    </div>\n    <!-- bottom -->\n    <div\n      v-show=\"videoElementReady && !(usePlayer === 'iframe')\"\n      class=\"absolute bottom-0 left-0 right-0 bg-black bg-opacity-75 transform transition-all ease-in-out duration-300\"\n      :class=\"{ 'translate-y-3/2': !showSettings && !showControlBar && userClickedPlaying }\"\n    >\n      <div class=\"h-full m-0 align-middle\">\n        <div ref=\"progressbar\" class=\"relative w-full h-1 bg-gray-600 transition-all ease-in-out\">\n          <div class=\"absolute h-full w-full overflow-hidden\">\n            <div v-if=\"hasAudioStream\" class=\"h-1/2 w-full\">\n              <div\n                v-for=\"(l, i) in videoLoadedRanges\"\n                :key=\"i\"\n                class=\"absolute h-1/2\"\n                :class=\"{ 'bg-orange-200': l.isBuffer }\"\n                :style=\"{ width: `${(l.end - l.start) * 100}%`, left: `${l.start * 100}%` }\"\n              />\n            </div>\n            <div v-if=\"hasAudioStream\" class=\"h-1/2 w-full\">\n              <div\n                v-for=\"(l, i) in audioLoadedRanges\"\n                :key=\"i\"\n                class=\"absolute h-1/2\"\n                :class=\"{ 'bg-purple-400': l.isBuffer }\"\n                :style=\"{ width: `${(l.end - l.start) * 100}%`, left: `${l.start * 100}%` }\"\n              />\n            </div>\n            <div v-else class=\"h-full w-full\">\n              <div\n                v-for=\"(l, i) in videoLoadedRanges\"\n                :key=\"i\"\n                class=\"absolute h-full\"\n                :class=\"{ 'bg-orange-200': l.isBuffer }\"\n                :style=\"{ width: `${(l.end - l.start) * 100}%`, left: `${l.start * 100}%` }\"\n              />\n            </div>\n          </div>\n          <div class=\"absolute h-full bg-purple-600\" :style=\"{ width: `${progress * 100}%` }\">\n            <span class=\"absolute right-0 top-0 w-3 h-3 -mt-1 -mr-1.5 bg-white rounded-full cursor-pointer\" />\n          </div>\n        </div>\n      </div>\n      <div class=\"flex flex-row justify-between flex-nowrap h-8 mx-4 my-1 text-white overflow-hidden\">\n        <div class=\"flex-grow-0 flex flex-row items-center\">\n          <div class=\"flex\" @click=\"onPlayPause\">\n            <div v-if=\"!streamsReady\" class=\"i-uil:spinner-alt text-2xl animate-spin\" />\n            <div v-else-if=\"playing\" class=\"i-uil:pause text-2xl\" />\n            <div v-else class=\"i-uil:play text-2xl\" />\n          </div>\n          <div class=\"px-1\" />\n          <div class=\"flex flex-row items-center gap-2\">\n            <div\n              class=\"flex items-center text-2xl\"\n              @click=\"\n                () => {\n                  volume = volume ? 0 : 1\n                }\n              \"\n            >\n              <div v-if=\"volume > 0\" class=\"i-uil:volume\" />\n              <div v-else class=\"i-uil:volume-mute\" />\n            </div>\n            <div class=\"lt-sm:hidden h-full m-0\">\n              <div ref=\"volumebar\" class=\"w-16 h-1 bg-gray-600 rounded-full transition-all ease-in-out\">\n                <div\n                  class=\"relative h-full left-0 bottom-0 bg-purple-600 rounded-l-full\"\n                  :style=\"{ width: `${volume * 100}%` }\"\n                >\n                  <span class=\"absolute -right-1.5 -top-1 w-3 h-3 bg-white rounded-full cursor-pointer\" />\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n        <div class=\"flex-grow-0 flex items-center\">\n          <span v-if=\"!disableFullscreen\" class=\"flex\" @click=\"onFullscreen\"><div v-if=\"!isFullscreen\" class=\"i-uil:expand-arrows-alt text-2xl\" />\n            <div v-else class=\"i-uil:compress-arrows text-2xl\" /></span><span class=\"px-1\" />\n        </div>\n      </div>\n    </div>\n    <!-- side -->\n    <div\n      v-show=\"videoElementReady && !(usePlayer === 'iframe') && showSettings\"\n      class=\"absolute top-0 bottom-0 left-0 right-0\"\n      @click=\"showSettings = false\"\n    />\n    <div\n      v-show=\"videoElementReady && !(usePlayer === 'iframe')\"\n      class=\"absolute top-0 bottom-0 right-0 bg-black transform transition-all duration-300 ease-in-out overflow-hidden\"\n      :class=\"{ 'translate-x-full': !showSettings }\"\n    >\n      <Transition\n        :enter-active-class=\"\n          transToParent\n            ? 'transition-all duration-250 transform'\n            : 'absolute top-0 transform transition-all duration-250'\n        \"\n        :leave-active-class=\"\n          transToParent\n            ? 'absolute top-0 transform transition-all duration-250'\n            : 'transition-all duration-250 transform'\n        \"\n        :enter-from-class=\"transToParent ? '-translate-x-full' : 'translate-x-full'\"\n        :leave-to-class=\"transToParent ? 'translate-x-full' : '-translate-x-full'\"\n      >\n        <div :key=\"activeSettingsItemName\" class=\"text-white w-72 overflow-x-hidden divide-y-1 divide-gray-600\">\n          <div class=\"px-2 pt-3 pb-2 font-medium\">\n            <div\n              v-if=\"activeSettingsItem.parent && activeSettingsItem.parent in settings\"\n              class=\"i-uil:arrow-left absolute text-2xl align-middle\"\n              @click=\"toSettingsParent\"\n            />\n            <div class=\"text-center select-none\" v-text=\"activeSettingsItem.name ?? activeSettingsItemName\" />\n          </div>\n          <div\n            v-for=\"(settingsItem, index) in activeSettingsItem.items\"\n            :key=\"index\"\n            class=\"px-2 py-1 whitespace-pre transform transition-all ease-in-out duration-100\"\n            :class=\"{\n              'hover:bg-gray-900 cursor-pointer':\n                'onClick' in settingsItem || 'to' in settingsItem,\n            }\"\n          >\n            <div\n              v-if=\"settingsItem.type === 'text'\"\n              :class=\"settingsItem.class\"\n              @click=\"settingsItem.onClick\"\n              v-text=\"settingsItem.text\"\n            />\n            <div\n              v-else-if=\"settingsItem.type === 'sub' && settingsItem.to in settings\"\n              @click=\"activeSettingsItemName = settingsItem.to\"\n            >\n              <div class=\"inline-block\" v-text=\"settingsItem.text\" />\n              <div class=\"inline-block float-right\">\n                <span v-if=\"settingsItem.rightText\" class=\"text-gray-300\" v-text=\"settingsItem.rightText\" />\n                <div class=\"i-uil:arrow-right inline-block text-2xl align-middle\" />\n              </div>\n            </div>\n            <SwitchGroup v-else-if=\"settingsItem.type === 'check'\">\n              <div class=\"flex justify-between\">\n                <SwitchLabel class=\"select-none\">\n                  {{ settingsItem.text }}\n                </SwitchLabel>\n                <PvSwitch v-model=\"settingsItem.checked.value\" size=\"sm\" />\n              </div>\n            </SwitchGroup>\n          </div>\n        </div>\n      </Transition>\n    </div>\n    <div\n      v-if=\"!videoElementReady && !(usePlayer === 'iframe')\"\n      class=\"absolute bottom-2 left-2 log overflow-y-scroll text-sm text-white\"\n    >\n      <p ref=\"logEl\" class=\"whitespace-pre\" v-text=\"logText\" />\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed, nextTick, onMounted, onUnmounted, ref, shallowRef, watch, watchEffect } from 'vue'\nimport {\n  useElementBounding,\n  useEventListener,\n  useFullscreen,\n  useIntervalFn,\n  useLocalStorage,\n  useRafFn,\n  useThrottleFn,\n  useTimeoutFn,\n} from '@vueuse/core'\nimport type { Fn, GeneralEventListener } from '@vueuse/core'\nimport type { Ref } from 'vue'\nimport { useI18n } from 'vue-i18n'\nimport type { FetchResult } from '@apollo/client/core'\nimport type FlvJs from 'flv.js'\nimport { SwitchGroup, SwitchLabel } from '@headlessui/vue'\nimport PvSwitch from '@/ui/components/PvSwitch.vue'\nimport { extensionTweaks } from '@/main/libs/extension'\n\ntype VideoData = GeneralVideoData | BilibiliVideoData | YoutubeVideoData\ninterface BaseVideoData {\n  streams: VideoStreamData[]\n}\ntype GeneralVideoData = BaseVideoData & {\n  extractor: ''\n}\ntype BilibiliVideoData = BaseVideoData & {\n  extractor: 'BiliBili'\n  extra: {\n    cid: number\n    danmaku: string\n    duration_ms: number\n  }\n}\ntype YoutubeVideoData = BaseVideoData & {\n  extractor: 'Youtube'\n  extra: {}\n}\ninterface VideoStreamData {\n  id: string\n  container: string\n  vcodec?: string\n  acodec?: string\n  quality: 'tiny' | '144p' | '240p' | '360p' | '480p' | '720p' | '1080p' | '1440p' | '2160p' | '2880p' | '4320p'\n  size?: number\n  tbr?: number\n  src: string[]\n}\ninterface VideoStream {\n  id: string\n  container: string\n  vcodec?: string\n  quality: '144p' | '240p' | '360p' | '480p' | '720p' | '1080p' | '1440p' | '2160p' | '2880p' | '4320p'\n  size?: number\n  tbr?: number\n  src: string[]\n  audioStreams?: AudioStream[]\n}\ninterface AudioStream {\n  id: string\n  container: string\n  acodec?: string\n  quality: 'tiny'\n  size?: number\n  tbr?: number\n  src: string[]\n}\ninterface SettingMenu {\n  id: string\n  name?: string\n  parent?: string\n  items: SettingItem[]\n}\ntype SettingItem = SettingText | SettingSub | SettingsCheck\ninterface SettingText {\n  type: 'text'\n  class?: string[]\n  text: string\n  rightText?: string\n  onClick?: GeneralEventListener<Event>\n}\ninterface SettingSub {\n  type: 'sub'\n  to: string\n  text: string\n  rightText?: string\n  onClick?: GeneralEventListener<Event>\n}\ninterface SettingsCheck {\n  type: 'check'\n  text: string\n  checked: Ref<boolean>\n}\ninterface VideoItem {\n  title: string\n  url: string\n  site: string\n}\n\nconst props = withDefaults(\n  defineProps<{\n    item: VideoItem\n    fullHeight?: boolean\n    disableFullscreen?: boolean\n  }>(),\n  {\n    fullHeight: false,\n    disableFullscreen: false,\n  },\n)\n\nconst qualities = ['144p', '240p', '360p', '480p', '720p', '1080p', '1440p', '2160p', '2880p', '4320p'].reverse()\nconst formats = ['webm_dash', 'mp4_dash', 'flv']\n\nconst { t } = useI18n()\n\nconst root = shallowRef<HTMLDivElement | null>(null)\nconst usePlayer = ref<'video' | 'iframe' | 'canvas'>('video')\nconst video = shallowRef<HTMLVideoElement | null>(null)\nconst { width } = useElementBounding(root)\nconst height = computed(() =>\n  video.value && video.value.videoWidth > 0 && video.value.videoHeight > 0\n    ? (width.value / video.value.videoWidth) * video.value.videoHeight\n    : (width.value / 16) * 9,\n)\n\n// video stream\nconst streamQuality = ref('')\nconst streams = ref<VideoStream[]>([])\nconst currentStream = ref<VideoStream | undefined>()\nconst hasAudioStream = ref(false)\n\n// full screen\nconst { isFullscreen, toggle: onFullscreen } = useFullscreen(root)\n\n// dedicated audio track\nconst audio = shallowRef<HTMLAudioElement | null>(null)\n// video ready state\nconst audioReady = ref(false)\nconst videoReady = ref(false)\nconst streamsReady = computed(() => videoReady.value && (!hasAudioStream.value || audioReady.value))\nlet stopVideoWait: Fn | undefined\nuseEventListener(video, 'waiting', () => {\n  const { stop } = useTimeoutFn(() => {\n    videoReady.value = false\n  }, 200)\n  stopVideoWait = stop\n})\nuseEventListener(video, 'canplay', () => {\n  if (stopVideoWait) {\n    stopVideoWait()\n    stopVideoWait = undefined\n  }\n  videoReady.value = true\n})\nlet stopAudioWait: Fn | undefined\nuseEventListener(audio, 'waiting', () => {\n  const { stop } = useTimeoutFn(() => {\n    audioReady.value = false\n  }, 200)\n  stopAudioWait = stop\n})\nuseEventListener(audio, 'canplay', () => {\n  if (stopAudioWait) {\n    stopAudioWait()\n    stopAudioWait = undefined\n  }\n  audioReady.value = true\n})\nuseEventListener(audio, 'timeupdate', () => {\n  if (!audio.value!.paused && audioReady.value && (!video.value || !videoReady.value || video.value.paused))\n    audio.value!.pause()\n})\n\nconst videoHasCors = ref(false)\nconst crossorigin = computed(() => videoHasCors.value || extensionTweaks.value.includes('enable_cors_requests'))\n\n/* control bar */\nconst showControlBar = ref(true)\nlet stopHideControlBar: Fn\nconst delayedHideControlBar = useThrottleFn((delay = 200) => {\n  if (stopHideControlBar)\n    stopHideControlBar()\n  const { stop } = useTimeoutFn(\n    () => {\n      showControlBar.value = false\n    },\n    delay,\n    { immediate: true },\n  )\n  stopHideControlBar = stop\n}, 200, true)\nuseEventListener(root, 'mousemove', () => {\n  if (stopHideControlBar)\n    stopHideControlBar()\n  showControlBar.value = true\n  if (isFullscreen.value)\n    delayedHideControlBar(800)\n})\nuseEventListener(root, 'mouseleave', () => {\n  delayedHideControlBar()\n})\n\n/* video settings */\nconst showSettings = ref(false)\n\nconst syncAudio = useLocalStorage('player_settings_sync_audio', false)\nconst useCanvas = ref(false)\nconst canvasTransparent = ref(false)\n\nconst settings = computed<Record<string, SettingMenu>>(() => ({\n  default: {\n    id: 'default',\n    name: t('video.player.settings.default.name'),\n    items: [\n      {\n        type: 'sub',\n        to: 'quality',\n        text: t('video.player.settings.default.items.quality'),\n        rightText: streamQuality.value,\n      },\n      {\n        type: 'check',\n        text: t('video.player.settings.default.items.audio'),\n        checked: syncAudio,\n      },\n      ...(() =>\n        crossorigin.value\n          ? ([\n              {\n                type: 'check',\n                text: t('video.player.settings.default.items.canvas'),\n                checked: useCanvas,\n              },\n              {\n                type: 'check',\n                text: t('video.player.settings.default.items.canvas-transparent'),\n                checked: canvasTransparent,\n              },\n            ] as SettingItem[])\n          : [])(),\n    ],\n  },\n  quality: {\n    id: 'quality',\n    name: t('video.player.settings.quality.name'),\n    parent: 'default',\n    items: [\n      ...(() => {\n        return currentStream.value\n          ? ([\n              {\n                type: 'text',\n                text: t('video.player.settings.quality.items.current-codec', {\n                  container: currentStream.value.container.replace(/_dash$/, ''),\n                  codec: currentStream.value.vcodec || 'unknown',\n                }),\n              },\n            ] as [SettingText])\n          : []\n      })(),\n      ...(() => {\n        const qualities: string[] = []\n        streams.value.forEach((stream) => {\n          if (!qualities.includes(stream.quality))\n            qualities.push(stream.quality)\n        })\n        return qualities.map(quality => ({\n          type: 'text',\n          text: `${streamQuality.value === quality ? '·' : ' '} ${quality}`,\n          onClick: () => playStream(quality),\n        })) as SettingText[]\n      })(),\n    ],\n  },\n}))\n\nconst activeSettingsItemName = ref('default')\nconst activeSettingsItem = computed(() => settings.value[activeSettingsItemName.value])\n\nconst transToParent = ref(false)\nwatch(activeSettingsItemName, (n, o) => {\n  transToParent.value = n === settings.value[o].parent\n})\nconst toSettingsParent = () => {\n  activeSettingsItemName.value = activeSettingsItem.value.parent as string\n}\n\n// loading log\nconst logText = ref('')\nconst logEl = shallowRef<HTMLParagraphElement | null>(null)\nconst log = (_log: string) => {\n  // console.log(`[Player] > ${_log}`)\n  logText.value += _log\n  nextTick(() => {\n    if (logEl.value) {\n      logEl.value.scrollIntoView({\n        block: 'end',\n      })\n    }\n  })\n}\n\n// play & pause\nconst playing = ref(false)\nconst userClickedPlaying = ref(false)\nconst onPlayPause = () => {\n  if (!userClickedPlaying.value)\n    userClickedPlaying.value = true\n  playing.value = !playing.value\n}\nconst updatePlaying = () => {\n  if (video.value && videoReady.value && (!hasAudioStream.value || (audio.value && audioReady.value))) {\n    try {\n      if (video.value.currentTime === video.value.duration) {\n        video.value.currentTime = 0\n        if (audio.value)\n          audio.value.currentTime = 0\n      }\n      if (playing.value && video.value.paused)\n        video.value.play()\n      if (!playing.value && !video.value.paused)\n        video.value.pause()\n    }\n    catch (_) {\n      //\n    }\n  }\n}\nuseIntervalFn(updatePlaying, 500)\nwatch(playing, updatePlaying)\nuseEventListener(video, 'ended', () => {\n  playing.value = false\n})\nonMounted(() => {\n  // for (const i of [\n  //   'audioprocess',\n  //   'canplay',\n  //   'canplaythrough',\n  //   'complete',\n  //   'durationchange',\n  //   'emptied',\n  //   'ended',\n  //   'loadeddata',\n  //   'loadedmetadata',\n  //   'pause',\n  //   'play',\n  //   'playing',\n  //   'progress',\n  //   'ratechange',\n  //   'seeked',\n  //   'seeking',\n  //   'stalled',\n  //   'suspend',\n  //   'timeupdate',\n  //   'volumechange',\n  //   'waiting',\n  // ]) {\n  //   video.value.addEventListener(i, (e) => {\n  //     console.log('video', i, e)\n  //   })\n  //   audio.value.addEventListener(i, (e) => {\n  //     console.log('audio', i, e)\n  //   })\n  // }\n  useEventListener(video, 'play', () => {\n    if (hasAudioStream.value && audio.value) {\n      audio.value.currentTime = video.value!.currentTime\n      audio.value.play()\n    }\n  })\n  useEventListener(video, 'pause', () => {\n    if (hasAudioStream.value && audio.value) {\n      audio.value.currentTime = video.value!.currentTime\n      audio.value.pause()\n    }\n  })\n})\nconst duration = ref(0)\nuseEventListener(video, 'durationchange', () => {\n  duration.value = video.value!.duration\n})\nconst videoElementReady = ref(false)\n\n// progress bar\nconst computeLoadedRanges = (amount: TimeRanges | null) => {\n  if (amount) {\n    const ranges = []\n    let last = 0\n    for (let i = 0; i < amount.length; i++) {\n      if (last < amount.start(i)) {\n        ranges.push({\n          isBuffer: false,\n          start: last,\n          end: amount.start(i),\n        })\n      }\n      ranges.push({\n        isBuffer: true,\n        start: amount.start(i),\n        end: amount.end(i),\n      })\n      last = amount.end(i)\n    }\n    if (last < duration.value) {\n      ranges.push({\n        isBuffer: false,\n        start: last,\n        end: duration.value,\n      })\n    }\n    return ranges.map(v => ({\n      isBuffer: v.isBuffer,\n      start: v.start / duration.value,\n      end: v.end / duration.value,\n    }))\n  }\n  else {\n    return [\n      {\n        isBuffer: false,\n        start: 0,\n        end: 1,\n      },\n    ]\n  }\n}\nconst currentTime = ref(0)\nconst videoLoadedAmount = ref<TimeRanges | null>(null)\nconst videoLoadedRanges = computed(() => computeLoadedRanges(videoLoadedAmount.value))\nconst audioLoadedAmount = ref<TimeRanges | null>(null)\nconst audioLoadedRanges = computed(() => computeLoadedRanges(audioLoadedAmount.value))\n// watch(videoLoadedRanges, () => console.log(videoLoadedRanges.value))\nconst progress = computed(() => currentTime.value / duration.value)\nconst progressbar = shallowRef<HTMLDivElement | null>(null)\nconst updateCurrentTime = () => {\n  if (video.value)\n    video.value.currentTime = currentTime.value\n  if (audio.value)\n    audio.value.currentTime = currentTime.value\n}\nuseEventListener(video, 'timeupdate', () => {\n  currentTime.value = video.value!.currentTime\n  if (hasAudioStream.value) {\n    if (videoReady.value && audioReady.value) {\n      // console.log(\n      //   'diff',\n      //   audio.value.currentTime,\n      //   video.value.currentTime,\n      //   audio.value.currentTime - video.value.currentTime\n      // )\n      if (audio.value && syncAudio.value && Math.abs(audio.value.currentTime - currentTime.value) > 0.1) {\n        audio.value.currentTime = video.value!.currentTime + (audio.value.currentTime - currentTime.value)\n        audio.value.play()\n      }\n      if (audio.value && audio.value.paused && !video.value!.paused)\n        audio.value.play()\n      if (audio.value && !audio.value.paused && video.value!.paused)\n        audio.value.pause()\n    }\n    else {\n      video.value!.pause()\n      watch(\n        audioReady,\n        () => {\n          if (audioReady.value && playing.value)\n            video.value!.play()\n        },\n        { flush: 'post' },\n      )\n    }\n  }\n  if (video.value)\n    videoLoadedAmount.value = video.value.buffered\n  if (audio.value)\n    audioLoadedAmount.value = audio.value.buffered\n})\n// useEventListener(video, 'progress', () => {\n//   videoLoadedAmount.value = video.value.buffered\n// })\n// useEventListener(audio, 'progress', () => {\n//   audioLoadedAmount.value = audio.value.buffered\n// })\nuseEventListener(progressbar, 'click', (e: MouseEvent) => {\n  let percentage = (e.clientX - progressbar.value!.getBoundingClientRect().left) / progressbar.value!.clientWidth\n  percentage = Math.max(0, Math.min(1, percentage))\n  currentTime.value = percentage * duration.value\n  updateCurrentTime()\n})\nuseEventListener(progressbar, 'mousedown', (e: DragEvent) => {\n  const stopMouseMove = useEventListener('mousemove', (e: MouseEvent) => {\n    let percentage = (e.clientX - progressbar.value!.getBoundingClientRect().left) / progressbar.value!.clientWidth\n    percentage = Math.max(0, Math.min(1, percentage))\n    currentTime.value = percentage * duration.value\n  })\n  const stopMouseUp = useEventListener('mouseup', (e: MouseEvent) => {\n    stopMouseMove()\n    stopMouseUp()\n    updateCurrentTime()\n  })\n})\n\n/* volume bar */\nconst volume = useLocalStorage('player_settings_volume', 0.5, { listenToStorageChanges: false })\nconst keepElementVolume = ref(false)\nwatch([volume, video, audio, keepElementVolume], () => {\n  let target = volume.value\n  if (keepElementVolume.value)\n    target = 1\n  if (video.value && video.value.volume !== target)\n    video.value.volume = target\n  if (audio.value && audio.value.volume !== target)\n    audio.value.volume = target\n})\nconst volumebar = shallowRef<HTMLDivElement | null>(null)\nuseEventListener(volumebar, 'click', (e: MouseEvent) => {\n  let percentage = (e.clientX - volumebar.value!.getBoundingClientRect().left) / volumebar.value!.clientWidth\n  percentage = Math.max(0, Math.min(1, percentage))\n  if (Number.isFinite(percentage))\n    volume.value = percentage\n})\nuseEventListener(volumebar, 'mousedown', (e: DragEvent) => {\n  const stopMouseMove = useEventListener('mousemove', (e: MouseEvent) => {\n    let percentage = (e.clientX - volumebar.value!.getBoundingClientRect().left) / volumebar.value!.clientWidth\n    percentage = Math.max(0, Math.min(1, percentage))\n    if (Number.isFinite(percentage))\n      volume.value = percentage\n  })\n  const stopMouseUp = useEventListener('mouseup', (e: MouseEvent) => {\n    stopMouseMove()\n    stopMouseUp()\n  })\n})\n\n// iframe mode\nconst regBili = /(https:\\/\\/|http:\\/\\/)www.bilibili.com\\/video\\/av(\\S+)\\?p=(\\S+)/\nconst regNico = /(https:\\/\\/|http:\\/\\/)www.nicovideo.jp\\/watch\\/sm(\\S+)/\nconst regU2b = /(https:\\/\\/|http:\\/\\/)www.youtube.com\\/watch\\?v=(\\S+)/\nconst regAcf = /(https:\\/\\/|http:\\/\\/)www.acfun.cn\\/v\\/ac(\\S+)/\nconst iframeUrl = ref('')\nfunction getIframeUrl(url: string) {\n  const bili = regBili.exec(url)\n  if (bili)\n    return `//player.bilibili.com/player.html?aid=${bili[2]}&page=${bili[3]}`\n  const nico = regNico.exec(url)\n  if (nico)\n    return `//embed.nicovideo.jp/watch/sm${nico[2]}`\n  const u2b = regU2b.exec(url)\n  if (u2b)\n    return `https://www.youtube.com/embed/${u2b[2]}`\n  const acf = regAcf.exec(url)\n  if (acf)\n    return `https://www.acfun.cn/player/ac${acf[2]}`\n}\nfunction loadIframe(url: string) {\n  log(`${t('video.player.iframe.enable')}\\n`)\n  const iurl = getIframeUrl(url)\n  if (!iurl) {\n    log(`${t('video.player.iframe.failed')}\\n`)\n    return false\n  }\n  iframeUrl.value = iurl\n  usePlayer.value = 'iframe'\n  return true\n}\n\n// stream mode\nconst getMIME = (container: string, codecs?: string, isAudio = false) =>\n    `${isAudio ? 'audio' : 'video'}/${container.replace(/_dash$/, '')}${codecs ? `; codecs=\"${codecs}\"` : ''}`\nconst isContainerSupported = (container: string, codecs?: string, isAudio = false) => {\n  if (['flv'].includes(container))\n    return true\n  return window.MediaSource.isTypeSupported(getMIME(container, codecs, isAudio))\n}\nlet flvPlayer: FlvJs.Player | undefined\nonUnmounted(() => {\n  flvPlayer?.destroy()\n})\nasync function playStream(quality: string) {\n  if (!video.value || !audio.value) {\n    await new Promise<void>((resolve) => {\n      watch(\n        [video, audio],\n        ([video, audio]) => {\n          if (video && audio)\n            resolve()\n        },\n      )\n    })\n  }\n  streamQuality.value = quality\n\n  flvPlayer?.destroy()\n\n  if (video.value) {\n    log(`${t('video.player.play-stream.source.video.source-changing')}\\n`)\n    const stream\n      = streams.value.filter(v => v.quality === quality).find(s => isContainerSupported(s.container, s.vcodec))\n      ?? streams.value.find(s => isContainerSupported(s.container, s.vcodec))\n    if (!stream) {\n      log(`${t('video.player.play-stream.source.video.source-nothing')}\\n`)\n      return false\n    }\n    const audioStream = stream.audioStreams\n      ? stream.audioStreams\n        .sort((a, b) => formats.indexOf(a.container) - formats.indexOf(b.container))\n        .sort((a, b) => (a.tbr ?? 0) - (b.tbr ?? 0))\n        .reverse()\n        .find(s => isContainerSupported(s.container, s.acodec, true))\n      : undefined\n    if (stream.audioStreams && !audioStream) {\n      log(`${t('video.player.play-stream.source.audio.source-nothing')}\\n`)\n      return false\n    }\n    // console.log(stream, audioStream)\n\n    try {\n      switch (stream.container) {\n        case 'flv': {\n          log(`${t('video.player.play-stream.container.flv.player-loading')}\\n`)\n          try {\n            const module = await import('flv.js')\n            const flvjs = module.default\n            log(`${t('video.player.play-stream.container.flv.parse-creating')}\\n`)\n            if ('createPlayer' in flvjs) {\n              flvPlayer = flvjs.createPlayer({\n                type: 'flv',\n                url: stream.src[0].replace(/^http:/, 'https:'),\n              })\n              flvPlayer.attachMediaElement(video.value!)\n              log(`${t('video.player.play-stream.container.flv.source-loading')}\\n`)\n              flvPlayer.load()\n              flvPlayer.on('metadata_arrived', () => {\n                log(`${t('video.player.play-stream.container.flv.player-loaded')}\\n`)\n                videoElementReady.value = true\n              })\n              hasAudioStream.value = false\n            }\n          }\n          catch (e) {\n            log(`${t('video.player.play-stream.container.flv.player-failed')}\\n${e}\\n`)\n            return false\n          }\n          return true\n        }\n        case 'webm_dash':\n        case 'mp4_dash': {\n          log(`${t('video.player.play-stream.container.mp4_dash.source-loading')}\\n`)\n          video.value.src = stream.src[0]\n          useEventListener(\n            video,\n            'canplay',\n            () => {\n              log(`${t('video.player.play-stream.container.mp4_dash.player-loaded')}\\n`)\n              currentStream.value = stream\n              videoElementReady.value = true\n            },\n            { once: true },\n          )\n          if (stream.audioStreams) {\n            audio.value!.src = stream.audioStreams[0].src[0]\n            audio.value!.currentTime = video.value.currentTime\n            audio.value!.load()\n            hasAudioStream.value = true\n          }\n          video.value.load()\n          return true\n        }\n      }\n    }\n    catch (e) {\n      log(`${t('video.player.play-stream.container.failed')}\\n${e}\\n`)\n      return false\n    }\n  }\n}\nasync function loadStream(url: string) {\n  try {\n    log(`${t('video.player.video.address-parsing')}\\n`)\n    const res = await fetch('https://patchyvideo.com/be/helper/get_video_stream', {\n      method: 'POST',\n      credentials: 'include',\n      headers: new Headers({\n        'Content-Type': 'application/json',\n      }),\n      body: JSON.stringify({\n        url,\n      }),\n    })\n    const result = (await res.json()) as FetchResult<VideoData>\n    if (!result.data)\n      return false\n    // console.log(result.data)\n    switch (result.data.extractor) {\n      case 'BiliBili': {\n        streams.value = result.data.streams as VideoStream[]\n        const stream = streams.value[0]\n        log(\n          `${t('video.player.video.profile.known-source', {\n            source: 'BiliBili',\n            format: stream.container,\n            quality: stream.quality,\n          })}\\n`,\n        )\n        videoHasCors.value = true\n        if (await playStream(stream.quality))\n          return true\n        break\n      }\n      case 'Youtube': {\n        let videoStreams: VideoStream[] = []\n        const audioStreams: AudioStream[] = []\n        result.data.streams.forEach((s) => {\n          if (s.quality === 'tiny')\n            audioStreams.push(s as AudioStream)\n          else\n            videoStreams.push(s as VideoStream)\n        })\n        videoStreams = videoStreams\n          .map(v => ({ ...v, audioStreams }))\n          .sort((a, b) => formats.indexOf(a.container) - formats.indexOf(b.container))\n          .sort((a, b) => qualities.indexOf(a.quality) - qualities.indexOf(b.quality))\n        streams.value = videoStreams\n        const stream = streams.value[0]\n        log(\n          `${t('video.player.video.profile.known-source', {\n            source: 'Youtube',\n            format: stream.container,\n            quality: stream.quality,\n          })}\\n`,\n        )\n        // console.log(streams)\n        if (await playStream(stream.quality))\n          return true\n        break\n      }\n      default: {\n        log(t('video.player.video.profile.unknown-source', { source: result.data.extractor }))\n        break\n      }\n    }\n    return false\n  }\n  catch (_) {\n    return false\n  }\n}\n\nconst sitesWithStream = [\n  'youtube',\n  // zyddnys 2021/8/7 22:01:32\n  // 那这样的话国内还是先用内嵌播放器 这样编辑才好看视频是不是东方\n  // 'bilibili',\n]\nasync function loadVideo(item: VideoItem) {\n  if (sitesWithStream.includes(item.site)) {\n    if (await loadStream(item.url))\n      return true\n  }\n\n  if (loadIframe(item.url))\n    return true\n  return false\n}\n\nconst url = ref('')\nwatch(\n  () => props.item.url,\n  async () => {\n    if (!props.item.url)\n      return\n    log(`${t('video.player.video.info-fetching')}\\n`)\n    url.value = props.item.url\n    log(`${t('video.player.video.URL', { url: url.value })}\\n`)\n    loadVideo(props.item)\n  },\n  {\n    immediate: true,\n  },\n)\n\nconst canvas = shallowRef<HTMLCanvasElement | null>(null)\n{\n  watchEffect(() => {\n    if (!crossorigin.value && usePlayer.value === 'canvas')\n      usePlayer.value = 'iframe'\n  })\n  watchEffect(() => {\n    if (useCanvas.value)\n      usePlayer.value = 'canvas'\n    else\n    if (usePlayer.value === 'canvas')\n      usePlayer.value = 'video'\n  })\n  let audioCtx: AudioContext | undefined\n  let gainNode: GainNode | undefined\n  let analyser: AnalyserNode | undefined\n  let frequencyBufferLength: number | undefined\n  let frequencyBuffer: Uint8Array | undefined\n  let source: MediaElementAudioSourceNode | undefined\n  let audioSourceType: 'audio' | 'video' | undefined\n  let clear: (() => void) | undefined\n  let watched = false\n  const frequencyBufferShift = 16\n  watchEffect(() => {\n    if (crossorigin.value && userClickedPlaying.value && !watched) {\n      watchEffect(() => {\n        if (hasAudioStream.value && audio.value && audioSourceType !== 'audio') {\n          if (clear)\n            clear()\n          audioCtx = new AudioContext()\n          source = audioCtx.createMediaElementSource(audio.value)\n          audioSourceType = 'audio'\n        }\n        else if (!hasAudioStream.value && video.value && audioSourceType !== 'video') {\n          if (clear)\n            clear()\n          audioCtx = new AudioContext()\n          source = audioCtx.createMediaElementSource(video.value)\n          audioSourceType = 'video'\n        }\n        else {\n          return\n        }\n        gainNode = audioCtx.createGain()\n        keepElementVolume.value = true\n        analyser = audioCtx.createAnalyser()\n        analyser.minDecibels = -90\n        analyser.maxDecibels = -10\n        analyser.smoothingTimeConstant = 0.8\n        analyser.fftSize = 4096\n        frequencyBufferLength = analyser.frequencyBinCount / 16 + frequencyBufferShift\n        frequencyBuffer = new Uint8Array(frequencyBufferLength)\n\n        if (audioCtx.state === 'suspended')\n          audioCtx.resume()\n        source.connect(gainNode)\n        source.connect(analyser)\n        gainNode.connect(audioCtx.destination)\n        clear = () => {\n          audioCtx?.close()\n          source?.disconnect(0)\n          source = undefined\n          gainNode?.disconnect(0)\n          gainNode = undefined\n          analyser?.disconnect(0)\n          analyser = undefined\n          clear = undefined\n        }\n      })\n      watchEffect(() => {\n        if (gainNode)\n          gainNode.gain.value = volume.value\n      })\n      watched = true\n    }\n  })\n  onUnmounted(() => {\n    if (clear)\n      clear()\n  })\n  let frame = 0\n  const ltrds: number[] = []\n  const { pause: pauseCanvasRender, resume: resumeCanvasRender } = useRafFn(\n    () => {\n      const cvs = canvas.value\n      const vid = video.value\n      if (cvs && !vid?.paused) {\n        const width = (cvs.width = cvs.clientWidth)\n        const height = (cvs.height = cvs.clientHeight)\n        const ctx = cvs.getContext('2d')\n        if (!ctx)\n          return\n\n        // clear canvas\n        if (canvasTransparent.value) {\n          ctx.clearRect(0, 0, width, height)\n        }\n        else {\n          ctx.fillStyle = 'rgb(0,0,0)'\n          ctx.fillRect(0, 0, width, height)\n        }\n\n        // draw shapes\n        if (analyser && frequencyBufferLength && frequencyBuffer) {\n          analyser.getByteFrequencyData(frequencyBuffer)\n          const deg = Math.PI / 12\n          const l = width + height * Math.tan(deg)\n          const w = l / (frequencyBufferLength - frequencyBufferShift) - 1\n          let x = 0\n          for (const frequency of frequencyBuffer.slice(frequencyBufferShift)) {\n            const c = frequency / 255\n            ctx.fillStyle = `rgba(255,255,255,${c / 2 + 0.2})`\n            ctx.beginPath()\n            const bx = x - (1 - c) * height * Math.tan(deg)\n            const by = (1 - c) * height\n            ctx.moveTo(bx, by)\n            ctx.lineTo(bx + w, by + w * Math.tan(deg))\n            const lx = x - height * Math.tan(deg)\n            ctx.lineTo(lx + w / Math.cos(deg) ** 2, height)\n            ctx.lineTo(lx, height)\n            ctx.fill()\n            x += w + 1\n          }\n        }\n\n        // status\n        {\n          ltrds.push(performance.now())\n          if (ltrds.length > 50)\n            ltrds.shift()\n          ctx.fillStyle = 'rgb(255,255,255)'\n          const text = `Frame: ${frame++} Width: ${width} Height: ${height} FPS: ${Math.floor(\n            1000 / ((ltrds[ltrds.length - 1] - ltrds[0]) / ltrds.length),\n          )}`\n          const w = (width - ctx.measureText(text).width) / 2\n          ctx.fillText(text, w, 20)\n        }\n      }\n    },\n    { immediate: false },\n  )\n  watch(\n    [usePlayer, playing, videoReady, audioReady],\n    () => {\n      if (\n        usePlayer.value === 'canvas'\n        && playing.value\n        && videoReady.value\n        && (!hasAudioStream.value || audioReady.value)\n      )\n        resumeCanvasRender()\n      if (\n        usePlayer.value !== 'canvas'\n        || !playing.value\n        || !videoReady.value\n        || (hasAudioStream.value && !audioReady.value)\n      )\n        pauseCanvasRender()\n    },\n    { immediate: true },\n  )\n}\n</script>\n\n<style lang=\"postcss\" scoped>\n.log::-webkit-scrollbar {\n  display: none;\n  width: 0px;\n  background: transparent;\n}\n.log {\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n}\n</style>\n"],"file":"assets/Player.cd2e18f0.js"}